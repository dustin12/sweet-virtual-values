(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define(['./sweet'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('sweet.js'));
    } else {
        root.returnExports = factory(root['sweet']);
    }
}(this, function (sweet) {
    'use strict';
    function compile(code) {
        var macroStr = '// vim: ts=4 sw=4\noperator ++ 15 { $op }     => #{ vvalues.unary("++", $op) }\noperator -- 15 { $op }     => #{ vvalues.unary("--", $op) }\noperator ! 14 { $op }      => #{ vvalues.unary("!", $op) }\noperator ~ 14 { $op }      => #{ vvalues.unary("~", $op) }\noperator + 14 { $op }      => #{ vvalues.unary("+", $op) }\noperator - 14 { $op }      => #{ vvalues.unary("-", $op) }\noperator typeof 14 { $op } => #{ vvalues.unary("typeof", $op) }\noperator void 14 { $op }   => #{ vvalues.unary("void", $op) }\n\noperator * 13 left { $left, $right }          => #{ vvalues.binary("*", $left, $right) }\noperator / 13 left { $left, $right }          => #{ vvalues.binary("/", $left, $right) }\noperator % 13 left { $left, $right }          => #{ vvalues.binary("%", $left, $right) }\noperator + 12 left { $left, $right }          => #{ vvalues.binary("+", $left, $right) }\noperator - 12 left { $left, $right }          => #{ vvalues.binary("-", $left, $right) }\noperator >> 11 left { $left, $right }         => #{ vvalues.binary(">>", $left, $right) }\noperator << 11 left { $left, $right }         => #{ vvalues.binary("<<", $left, $right) }\noperator >>> 11 left { $left, $right }        => #{ vvalues.binary(">>>", $left, $right) }\noperator < 10 left { $left, $right }          => #{ vvalues.binary("<", $left, $right) }\noperator <= 10 left { $left, $right }         => #{ vvalues.binary("<=", $left, $right) }\noperator > 10 left { $left, $right }          => #{ vvalues.binary(">", $left, $right) }\noperator >= 10 left { $left, $right }         => #{ vvalues.binary(">=", $left, $right) }\noperator in 10 left { $left, $right }         => #{ vvalues.binary("in", $left, $right) }\noperator instanceof 10 left { $left, $right } => #{ vvalues.binary("instanceof", $left, $right) }\noperator == 9 left { $left, $right }          => #{ vvalues.binary("==", $left, $right) }\noperator != 9 left { $left, $right }          => #{ vvalues.binary("!=", $left, $right) }\noperator === 9 left { $left, $right }         => #{ vvalues.binary("===", $left, $right) }\noperator !== 9 left { $left, $right }         => #{ vvalues.binary("!==", $left, $right) }\noperator & 8 left { $left, $right }           => #{ vvalues.binary("&", $left, $right) }\noperator ^ 7 left { $left, $right }           => #{ vvalues.binary("^", $left, $right) }\noperator | 6 left { $left, $right }           => #{ vvalues.binary("|", $left, $right) }\noperator && 5 left { $left, $right }          => #{ vvalues.binary("&&", $left, $right) }\noperator || 4 left { $left, $right }          => #{ vvalues.binary("||", $left, $right) }\n\nlet if = macro {\n    rule { ($cond ...) { $body ...} } => {\n        var c = $cond...;\n        let pushedProxy = vvalues.__pushContext(c);\n        if (c) {\n            $body ...;\n        }\n        if (pushedProxy) vvalues.__popContext();\n    }\n    rule { ($cond ...) { $thnBody ...} else { $elsBody ... } } => {\n        let c = $cond...;\n        let pushedProxy = vvalues.__pushContext(c);\n        if (c) {\n            $thnBody ...;\n        } else {\n            $elsBody ...;\n        }\n        if (pushedProxy) vvalues.__popContext();\n    }\n}\n\nlet = = macro {\n    rule infix { $left:expr | $right:expr } => {\n        let ctx = vvalues.__peekContext();\n        vvalues.assign(ctx, $left, $right, (polisher) => {\n            if (polisher) {\n                $left = polisher($right);\n            } else {\n                $left = $right;\n            }\n        });\n    }\n}\n\n';
        var harnessStr = 'var // vim: ts=4 sw=4\nvvalues = function () {\n    if (typeof require === \'function\') {\n        // importing patches Proxy to be in line with the new direct proxies\n        require(\'harmony-reflect\');\n    }\n    var // hold on to all the proxies we create so that we can retrieve the handlers later\n    unproxyMap = new WeakMap();\n    var oldProxy = Proxy;\n    function ValueShell(value) {\n        this.value = value;\n    }\n    ValueShell.prototype.valueOf = function () {\n        return this.value;\n    };\n    function VProxy(value, handler, key) {\n        var valueShell = new ValueShell(value);\n        var val = function (a0) {\n            if (a0 === void 0) {\n                return valueShell;\n            }\n            if (a0 === null) {\n                return valueShell;\n            }\n            if (typeof a0 !== \'object\') {\n                var x = a0;\n                return valueShell;\n            }\n            return value;\n        }.call(this, value);\n        var p = new oldProxy(val, handler);\n        unproxyMap.set(p, {\n            handler: handler,\n            key: key,\n            target: val\n        });\n        return p;\n    }\n    this.Proxy = VProxy;\n    function isVProxy(value) {\n        return value && typeof value === \'object\' && unproxyMap.has(value);\n    }\n    function unary(a0, a1) {\n        if (// @ (Str, Any) -> Any\n            isVProxy(a1)) {\n            var operator = a0;\n            var op = a1;\n            var target = unproxyMap.get(op).target;\n            return unproxyMap.get(op).handler.unary(target, operator, op);\n        }\n        if (a0 === \'-\') {\n            var op = a1;\n            return -op;\n        }\n        if (a0 === \'+\') {\n            var op = a1;\n            return +op;\n        }\n        if (a0 === \'++\') {\n            var op = a1;\n            return ++op;\n        }\n        if (a0 === \'--\') {\n            var op = a1;\n            return --op;\n        }\n        if (a0 === \'!\') {\n            var op = a1;\n            return !op;\n        }\n        if (a0 === \'~\') {\n            var op = a1;\n            return ~op;\n        }\n        if (a0 === \'typeof\') {\n            var op = a1;\n            return typeof op;\n        }\n        if (a0 === \'void\') {\n            var op = a1;\n            return void op;\n        }\n        throw new TypeError(\'No match\');\n    }\n    function binary(a0, a1, a2) {\n        if (// @ (Str, Any, Any) -> Any\n            isVProxy(a1)) {\n            var operator = a0;\n            var left = a1;\n            var right = a2;\n            var target = unproxyMap.get(left).target;\n            return unproxyMap.get(left).handler.left(target, operator, right);\n        }\n        if (isVProxy(a2)) {\n            var operator = a0;\n            var left = a1;\n            var right = a2;\n            var target = unproxyMap.get(right).target;\n            return unproxyMap.get(right).handler.right(target, operator, left);\n        }\n        if (a0 === \'*\') {\n            var left = a1;\n            var right = a2;\n            return left * right;\n        }\n        if (a0 === \'/\') {\n            var left = a1;\n            var right = a2;\n            return left / right;\n        }\n        if (a0 === \'%\') {\n            var left = a1;\n            var right = a2;\n            return left % right;\n        }\n        if (a0 === \'+\') {\n            var left = a1;\n            var right = a2;\n            return left + right;\n        }\n        if (a0 === \'-\') {\n            var left = a1;\n            var right = a2;\n            return left - right;\n        }\n        if (a0 === \'>>\') {\n            var left = a1;\n            var right = a2;\n            return left >> right;\n        }\n        if (a0 === \'<<\') {\n            var left = a1;\n            var right = a2;\n            return left << right;\n        }\n        if (a0 === \'>>>\') {\n            var left = a1;\n            var right = a2;\n            return left >>> right;\n        }\n        if (a0 === \'<\') {\n            var left = a1;\n            var right = a2;\n            return left < right;\n        }\n        if (a0 === \'<=\') {\n            var left = a1;\n            var right = a2;\n            return left <= right;\n        }\n        if (a0 === \'>\') {\n            var left = a1;\n            var right = a2;\n            return left > right;\n        }\n        if (a0 === \'>=\') {\n            var left = a1;\n            var right = a2;\n            return left >= right;\n        }\n        if (a0 === \'in\') {\n            var left = a1;\n            var right = a2;\n            return left in right;\n        }\n        if (a0 === \'instanceof\') {\n            var left = a1;\n            var right = a2;\n            return left instanceof right;\n        }\n        if (a0 === \'==\') {\n            var left = a1;\n            var right = a2;\n            return left == right;\n        }\n        if (a0 === \'!=\') {\n            var left = a1;\n            var right = a2;\n            return left != right;\n        }\n        if (a0 === \'===\') {\n            var left = a1;\n            var right = a2;\n            return left === right;\n        }\n        if (a0 === \'!==\') {\n            var left = a1;\n            var right = a2;\n            return left !== right;\n        }\n        if (a0 === \'&\') {\n            var left = a1;\n            var right = a2;\n            return left & right;\n        }\n        if (a0 === \'^\') {\n            var left = a1;\n            var right = a2;\n            return left ^ right;\n        }\n        if (a0 === \'|\') {\n            var left = a1;\n            var right = a2;\n            return left | right;\n        }\n        if (a0 === \'&&\') {\n            var left = a1;\n            var right = a2;\n            return left && right;\n        }\n        if (a0 === \'||\') {\n            var left = a1;\n            var right = a2;\n            return left || right;\n        }\n        throw new TypeError(\'No match\');\n    }\n    function assign(ctx, left, right, assignThunk) {\n        if (isVProxy(ctx) && unproxyMap.get(ctx).handler.assign) {\n            return unproxyMap.get(ctx).handler.assign(ctx, left, right, assignThunk);\n        } else if (isVProxy(left) && unproxyMap.get(left).handler.assign) {\n            return unproxyMap.get(left).handler.assign(ctx, left, right, assignThunk);\n        } else if (isVProxy(right) && unproxyMap.get(right).handler.assign) {\n            return unproxyMap.get(right).handler.assign(ctx, left, right, assignThunk);\n        }\n        // No handler used if we made it here\n        return assignThunk();\n    }\n    var ctxStack = [];\n    function pushContext(x) {\n        if (isVProxy(x)) {\n            ctxStack.push(x);\n            return true;\n        }\n        return false;\n    }\n    function popContext() {\n        return ctxStack.pop();\n    }\n    function peekContext() {\n        return ctxStack[ctxStack.length - 1];\n    }\n    this.unproxy = function (value, key) {\n        if (isVProxy(value) && unproxyMap.get(value).key === key) {\n            return unproxyMap.get(value).handler;\n        }\n        return null;\n    };\n    return {\n        unary: unary,\n        binary: binary,\n        assign: assign,\n        __pushContext: pushContext,\n        __popContext: popContext,\n        __peekContext: peekContext\n    };\n}();';
        var expanded = sweet.compile(macroStr + '\n' + code);
        return harnessStr + '\n' + expanded.code;
    }
    return { compile: compile };
}));